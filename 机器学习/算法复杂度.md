# 算法复杂度

算法的效率主要由以下两个复杂度来评估：

- **时间复杂度**：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。 
- **空间复杂度**：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。

**注意**：*一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。*

## 时间复杂度

**时间频度**：现实情况中不可能也没有必要对每个算法都上机测试它的真实性能，只需要知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。一个算法花费的时间与算法中语句的执行次数成正比例。算法中语句执行次数越多，它花费的时间就越多。一个算法中的语句执行次数称为**语句频度**或**时间频度**。记为 $T(n)$。

在时间频度 $T(n)$ 中，$n$ 称为问题的规模。当 $n$ 变化时，时间频度 $T(n)$ 也会随之变化。

一般情况下，算法中基本操作重复执行的次数是问题规模 $n$ 的某个函数，用 $T(n)$ 表示。若有某个辅助函数 $f(n)$，使得当 $n$ 趋近于无穷大时，$\frac {T(N)} {f(n)}$ 的极限值为不等于零的常数，则称 $f(n)$ 是 $T(n)$ 的同数量级函数，记作：

$$T(n)=O(f(n))$$

它称为算法的**渐进时间复杂度**，简称**时间复杂度**。用 $O()$ 来体现算法时间复杂度的记法，称之为 **大 $O$ 表示法**。

算法复杂度可以从：最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要*直接估算最坏情况的复杂度*。

推导一个算法的由大 $O$ 阶表示法表示的复杂度，其步骤如下：

1. 用常数 $1$ 取代运行时间中的所有加法常数。

2. 在修改后的运行次数函数中，只保留最高阶项。

3. 如果最高阶项存在且不是 $1$，则去除与这个项目相乘的常数。

大 $O$ 表示法常见的种类一般如下：

- **常数阶$O(1)$**：$f(n)=1$，所需时间与问题规模 $n$ 无关。

```python {.line-numbers}
# f(n) = 3
n = 100                 # 一次计算
sum = (1 + n) * n / 2   # 一次计算
print(sum)              # 一次计算
```

- **线性阶$O(n)$**：$f(n)=1$，所需时间是问题规模 $n$ 的倍数。

```python {.line-numbers}
for i in range(n):
    o1_function()       # 任意时间复杂度为O(1)的算法
```

- **对数阶$O(\log(n))$**：$f(n)=\log(n)$，所需时间是问题规模 $n$ 的倍数。

```python {.line-numbers}
count = 1
while count < n:
    count = count * 2
    o1_function()       # 任意时间复杂度为O(1)的算法
```

- **平方阶$O(n^2)$**：$f(n)=n^2$，所需时间是问题规模 $n$ 的平方。

```python {.line-numbers}
for i in range(n):
    for j in range(n):
        o1_function()   # 任意时间复杂度为O(1)的算法
```

## 空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：$S(n)=O(f(n))$，其中，$n$ 为问题的规模，$f(n)$ 为语句关于 $n$ 所占存储空间的函数。
