### 太平反欺诈：设计文档 ###

----------

本文档将从  

1. 设计的背景，即以前方法的总体思路和结构设计  
2. 设计的改进，即现在方法的逻辑计算  
3. 设计的不足，即以后可以改进的地方
  
这三个方面来展开讨论。

#### 算法的背景 ####

太平反欺诈的总体思路分为两个步骤：  

1. 
对于某疾病，将该病下的总样本依据某些**条件**划分成若干子样本，使得划分后的样本有：子样本之间的**费用**分布有差异，呈水平；子样本内部的**费用**分布保持稳定和趋同，以正态分布为目标。  
对于划分后的子样本，寻找这些样本除上述**条件**以外的共同特征，具体为：在医院做过的项目，并发症的种类和频率，投的是哪些保险。将这些共同特征以表格和数据的形式存储起来，组成一套（四个）模板。

2. 
现有一批新增的数据，我们根据这批数据中每一个主体的**费用**和对应于模板的信息，来判断这个主体应该属于哪一个模板，并和该模板的相似度有多高。得出的相似度为：该主体与其最匹配的模板的相似程度。

该模型的总体思路是没有错误的，但是具体的计算过程中，存在许多逻辑错误。为配合该项目的具体情况，如不能改变其算法流程和表结构，后续的算法编写保持该总体思想不变，但是会更改具体的实现方式。

#### 算法的改进 ####

对于原来的计算方法，首先更改的是：如何将总样本根据**条件**划分成子样本。使用切割的方法是不可取的，因为其涉及到数量巨大的切割顺序，无法完全模拟。此外，使用切割的方法将无法获取某些特定的子样本。

##### 划分样本 #####

```{r echo=FALSE}
source('script/function.R', encoding = 'UTF-8')
suppressMessages(suppressWarnings(library(dplyr)))

sample.data = matrix(nrow = 1000, ncol = 5)
sample.data[, 1] <- 1:nrow(sample.data)
sample.data[, 2] <- runif(1000, 1, 4) %>% as.integer()
sample.data[, 3] <- runif(1000, 1, 3) %>% as.integer()
sample.data[, 4] <- runif(1000, 1, 4) %>% as.integer()
sample.data[, 5] <- abs(rnorm(1000, 1000, 300) %>% sort() + rnorm(1000, 10000, 300))
colnames(sample.data) <- c('ID', 'A', 'B', 'C', 'ZFY')
sample.data <- data.frame(sample.data)
sample.data[2:4] <- lapply(sample.data[2:4], as.factor)
```

本次所使用的方法为：依据**条件**，将总样本切割为不可切割的最小状态，即不能再分的最小样本。考虑如下的假设数据集：

```{r echo=FALSE}
str(sample.data)
```

该假设数据集中，可用于将总样本划分为子样本的**条件**为数据集的中间三列（A、B、C），即三个**条件**，每个**条件**下有2个以上的水平，如下：

	A: A1 	A2 	A3
	B: B1 	B2
	C: C1 	C2 	C3

以ID为主键，每个ID代表一个主体，从数据库中抽取出该主体的三个**条件**（A、B、C）的信息，合并到一张表格中，其结构应该与上述假设数据集类似。

```{r echo=FALSE}
head(sample.data)
```

每一行即为一个主体。第一列*ID*为主体对应的索引。主体必然属于三个条件下若干水平的组合中的一种。每一个主体在*ZFY*列中对应有一条费用记录，即**费用**。

该数据集理论上的**最小样本**数，等于理论上该数据集的三个条件的所有水平下可能的组合数：  

	最小样本数 = 水平组合数 = 3(A水平数) * 2（B水平数） * 3(C水平数) = 18

然而，存在某种水平组合不存在的情况，特别是当样本偏少的时候。但是可以得知，任何样本都可以根据其**条件**划分为可穷尽的**最小样本**。我们对上述假设数据集进行整合，得出其18个**最小样本**。

```{r echo=FALSE}
by_sample <- group_by(sample.data, A, B, C)
atom.data <- summarise(by_sample,
                       ZFY.data = paste(round(ZFY, digits = 2), collapse = ','),
                       ID.data = paste(ID, collapse = ','), 
                       freq = length(ZFY))
atom.data[['index']] <- 1:nrow(atom.data) 
atom.data <- as.data.frame(atom.data)
atom.data <- atom.data[c('index', 'A', 'B', 'C', 'freq', 'ZFY.data', 'ID.data')]

atom.data[1:5]
```

每一行代表一个**最小样本**，故每一行还对应一个字符串向量和一个数值向量。前者存储该**最小样本**对应的**主体**ID是哪一些，后者存储这些ID的**费用**为多少。
如第一行（A = 1, B = 1, C = 1下的**最小样本**）所对应的两个向量为:

```{r echo=TRUE}
print(atom.data[1, 'ID.data'])
```
```{r echo=TRUE}
print(atom.data[1, 'ZFY.data'])
```

根据可穷尽的**最小样本**数据，以*index*为最小样本的索引，*ZFY.data*为每个最小样本下的总费用数据集。要将这些最小样本聚合起来，我们就必须要找到一种聚类的方法，其必须能处理两个长度不一样的数值向量。

##### 聚类的方法 #####

一般的聚类方法依赖于距离的度量，需要聚类的对象之间必须有相同的属性，比如：两者均为二维数据。在本例中，两个样本之间聚类的标的是关于**费用**的数值向量，长度不等。于是本文能提供的聚类方法如下：

1. 不依赖传统的距离度量方法。令一个数值向量为一个主体，两个向量（A、B）之间的距离定义为:将两个向量合并后的方差值。以此构造出所有向量的方差矩阵，来找到组合后方差最小的向量组合，并将该组合对应的两个样本合并，形成新的子样本，并重新计算矩阵。迭代并使得最后子样本的个数达到指定值或满足某个条件。

2. 找到一种方法，让数值向量标准化，标准化后所有向量均拥有相同的属性。构造向量完成后，可以使用各种距离度量方法来聚合，迭代并使得最后子样本的个数达到指定值或满足某个条件。

鉴于第一种方法的计算开销太大，本文使用第二种方法来进行。

##### 构造向量 #####
构造的向量必须在很大程度上能概括原有数值向量的信息，才能够用于聚类。故不可以用原数值向量的：均值、方差或概括性的数值。

本文使用的方法为：为每个数值向量构造一个轮廓向量，其主要概念是离散化及确定数值向量的分布模式。确定分布模式的目的是为了比较数值向量之间的差异，这就需要量化。将数值向量依据其大小分配到若干个等级中。

求出上述18个**最小样本**的轮廓矩阵（样例），如下：

```{r echo=FALSE}
profile.data = GetProfile(atom.data)
print(profile.data)
```

##### 距离度量 #####

如何根据上述指标来求出两个模式之间的差异，即距离的选择，是聚类的关键之二。本次分析使用余弦相似度来度量，特点如下：

- 对异常值敏感

- 不需要去除量纲，即不受比例的影响

生成的距离矩阵如下：

```{r echo=FALSE}
prof.v <- vector()
for(i in 1:nrow(profile.data)) {
    prof.v <- append(prof.v, paste(profile.data[i, ][-1], collapse = ','))
}

dist.m <- outer(prof.v, prof.v, CosSimi)
print(dist.m[1:10, 1:10])
```

根据距离矩阵，使用层次聚类方法，将**最小样本**聚合成合适的类的个数。


##### 实际情况 #####

在实际情况中，对应于上述的**条件**，我们选取以下条件：

```{r echo=FALSE}
TJ = c('年龄','事故原因代码', '事故结果', '年龄等级', '婚姻状况', '案件类型事故性质', '是否有驾照', '是否吸烟', '性别', '医院等级', '住院天数')
print(TJ)
```

聚类完成后，根据ID，寻找每一类对应的并发症、项目、险种责任数据，并将其汇总，求出其出现频率。



#### 改进的空间 ####

1. 是否可以不使用距离度量。

2. 聚类完成后，并发症、项目、责任数据的收集过于仓促，仅求各水平下的出现频率。

3. 住院天数作为一个条件出现，因为二维的聚类效果不理想。若使用二维聚类，该如何操作？

